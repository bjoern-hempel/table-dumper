#!/usr/bin/env bash

# README
# ------
# This script creates single table dumps and can even imports table dumps.

# Current version
# ---------------
# version: ENV_VERSION="0.1.1 (2022-05-22 00:19:34)" # auto-generated by bin/table-dumper -u

# Changelog
# ---------
# @see CHANGELOG.md

# Preparation:
# ------------
# $ cp .env.dist .env

# script configs
FILE_SCRIPT_ABSOLUTE="$(cd -- "$(dirname "$0")" >/dev/null 2>&1; pwd -P)/"$(basename "$0") # Symlink path
PATH_SCRIPT_ABSOLUTE="$(cd -- "$(dirname "$0")" >/dev/null 2>&1; pwd -P)" # Symlink path
FILE_SCRIPT_ABSOLUTE_DB_HELPER="$(realpath "$0")" # Real table-dumper path
PATH_SCRIPT_ABSOLUTE_DB_HELPER="$(dirname "$FILE_SCRIPT_ABSOLUTE_DB_HELPER")" # Real table-dumper path
PATH_ROOT=$(dirname "$PATH_SCRIPT_ABSOLUTE")
PATH_ROOT_DB_HELPER=$(dirname "$PATH_SCRIPT_ABSOLUTE_DB_HELPER")
FILE_VERSION_ABSOLUTE="$PATH_ROOT_DB_HELPER/VERSION"
PARAMETERS=()

# some environment variables
ENV_SCRIPTNAME=$(basename "$0")
ENV_VERSION=$(cat "$0" | grep --color=never "^# version:" | sed -n "s/.*ENV_VERSION=\"\([^\"]*\).*/\1/p")
ENV_VERSION_FORMAT=$(
    printf '# version: ENV_VERSION="%s (%s)" # auto-generated by bin/table-dumper -u' "$(cat "$FILE_VERSION_ABSOLUTE")" "$(date -r "$FILE_VERSION_ABSOLUTE" "+%Y-%m-%d %H:%M:%S")" | \
    sed -e 's/\#/\\\#/g' | \
    sed -e 's/\//\\\//g'
)
ENV_AUTHOR='Björn Hempel'
ENV_EMAIL='bjoern@hempel.li'
ENV_NAME='Simple Table Dumper'

# relative files
FILE_LOG_RELATIVE="table-dumper.log"
FILE_LOCK_RELATIVE="table-dumper.lock"
FILE_LOG_ABSOLUTE="$PATH_ROOT/$FILE_LOG_RELATIVE"
FILE_LOCK_ABSOLUTE="$PATH_ROOT/$FILE_LOCK_RELATIVE"

# some default settings (from parameter) - config
SETTING_SHOW_TIME=true
SETTING_VERBOSE=false
SETTING_COLOR=false
SETTING_DEBUG=false
SETTING_DISABLE_COLUMN_STATISTICS=false
SETTING_DEFAULT_ENV_PATH=".env"
SETTING_ENV_PATH=""
SETTING_SQL_FIXTURE_PATH_RELATIVE="fixtures/db"
SETTING_LOG_LINES=20

# some colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
RESET='\033[0m'

# EXIT codes
EXIT_CODE_APP_LOCKED=30

# Some texts
TEXT_NO_DATA_GIVEN="No data was given."
TEXT_NO_FILTER_GIVEN="No filter was set."

# Other config
WIDTH_VALUE=79

# =====
#
# Task function: Set lock function
#
# =====
function setLock
{
    # Check if there is currently a lock in place, if so then exit, if not then create a lock
    if [ -f "$FILE_LOCK_ABSOLUTE" ]; then
    	  error "A table-dumper sync is currently already running: Can't create a lock file. Lock file \"$FILE_LOCK_ABSOLUTE\" already exists. Abort." && exit $EXIT_CODE_APP_LOCKED
    else
	      info "Lock application."
    	  touch "$FILE_LOCK_ABSOLUTE"

	      if [ ! -f "$FILE_LOCK_ABSOLUTE" ]; then
            error "Unable to write lock file \"$FILE_LOCK_ABSOLUTE\". Failed. Abort." && exit 31
        fi

	      success "Lock file \"$FILE_LOCK_ABSOLUTE\" successfully written. Done."
    fi
}

# =====
#
# Task function: Unset lock function
#
# =====
function unsetLock
{
    # Check lock file
    if [ ! -f "$FILE_LOCK_ABSOLUTE" ]; then
        error "Unexpected status: Can't find lock file \"$FILE_LOCK_ABSOLUTE\". Abort." && exit 40
    fi

    # Remove lock file
    info "Remove application lock."
    rm "$FILE_LOCK_ABSOLUTE"

    #Check if there is currently a lock in place, if so then exit, if not then create a lock
    if [ -f "$FILE_LOCK_ABSOLUTE" ]; then
	      error "Unable to delete the lock file \"$FILE_LOG_ABSOLUTE\". Abort." && exit 41
    fi

    success "Lock file \"$FILE_LOCK_ABSOLUTE\" successfully deleted. Done."
}

# =====
#
# Task function: Cleanup
#
# =====
function cleanup
{
    # get exit code
    local exitCode=$?

    # Try to delete the lock file
    if [ $exitCode -ne $EXIT_CODE_APP_LOCKED ]; then
        info "Unlock application" && unsetLock
    fi

    # print summary message
    if [ $exitCode -gt 0 ]; then
        error "The script $ENV_SCRIPTNAME ended unexpectedly with the status code $exitCode. Please check the output beforehand."
    else
	      success "The script $ENV_SCRIPTNAME was executed successfully."
    fi

    # some styling
    echo -e "\n"

    # Exit the script finally
    exit $exitCode;
}


# =====
#
# Helper function: print header
#
# =====
function printHeader
{
    local header="$1"
    local separator=") "
    local headerParts=()
    local i

    # split header by |
    IFS='|' && read -a headerParts <<< "$header"

    # count header parts
    local headerPartsCount=${#headerParts[@]}

    # only first element to uppercase
    if [ $headerPartsCount -gt 1 ]; then
        header=""
        for ((i=0; i < $headerPartsCount; i++)); do
            if [ $i -gt 0 ]; then
                header+="${headerParts[$i]^^}"
            else
                header+="${headerParts[$i]} "
            fi
        done
    else
        header="${header^^}"
    fi

    local length=${#header}
    echo
    echo "$header"
    printf %${length}s |tr " " "="
    echo "" && echo ""

    # Reset IFS
    IFS=' '
}

# =====
#
# Helper function: Print info/error message
#
# =====
function message
{
    local message="$1"
    local messageType="${2:-info}"
    local lineBreak=${3:-true}
    local first=${4:-true}
    local logToFile=${5:-false}
    local logTime=${6:-$SETTING_SHOW_TIME}
    local startTime=$(date '+%Y-%m-%d %H:%M:%S')

    # Print the start of the message
    if $first; then
        $logTime && echo -n "[$startTime] "

        printf "%-9s → " "($messageType)"
    fi

    # Print the given message
    echo -n "$message"

    # Adds a line break
    if $lineBreak; then
        echo
    else
        echo -n " "
    fi

    # remove color
    echo -ne "$RESET"

    # log message to log file
    if $logToFile; then
        echo "[$startTime] - $messageType - $message" >> $FILE_LOG_ABSOLUTE
    fi
}

# =====
#
# Helper function: Print info
#
# =====
function info
{
    # show message(string $message, bool $lineBreak = true, bool $firstPart = true, bool $logToFile = false)
    message "$1" "info" ${2:-true} ${3:-true} ${4:-false}
}

# =====
#
# Helper function: Print verbose
#
# =====
function verbose
{
    # show message(string $message, bool $lineBreak = true, bool $firstPart = true, bool $logToFile = false)
    $SETTING_VERBOSE && message "$1" "verbose" ${2:-true} ${3:-true} ${4:-false}
}

# =====
#
# Helper function: Print success
#
# =====
function success
{
    # set color
    echo -ne "$GREEN"

    # show message(string $message, bool $lineBreak = true, bool $firstPart = true, bool $logToFile = false)
    message "$1" "success" ${2:-true} ${3:-true} ${4:-false}

    # remove color
    echo -ne "$RESET"
}

# =====
#
# Helper function: Print error
#
# =====
function error
{
    # set color
    echo -ne "$RED"

    # show message(string $message, bool $lineBreak = true, bool $firstPart = true, bool $logToFile = true)
    message "$1" "error" ${2:-true} ${3:-true} ${4:-true}

    # remove color
    echo -ne "$RESET"
}

# =====
#
# Helper function: Print command
#
# =====
function command
{
    # set color
    echo -ne "$YELLOW"

    # show message(string $message, bool $lineBreak = true, bool $firstPart = true, bool $logToFile = false)
    message "Local: $1" "command" ${2:-true} ${3:-true} ${4:-false}

    # remove color
    echo -ne "$RESET"
}

# =====
#
# Helper function: Print skipped
#
# =====
function skipped
{
    # set color
    echo -ne "$BLUE"

    # show message(string $message, bool $lineBreak = true, bool $firstPart = true, bool $logToFile = false)
    message "Local: $1" "skipped" ${2:-true} ${3:-true} ${4:-false}

    # remove color
    echo -ne "$RESET"
}

# =====
#
# Replaces the replace function because macs missing readlink -f
# (mac is BSD-version and we need the gnu version)
#
# =====
function realpath()
{
    OURPWD=$PWD
    cd "$(dirname "$1")"
    LINK=$(readlink "$(basename "$1")")
    while [ "$LINK" ]; do
        cd "$(dirname "$LINK")"
        LINK=$(readlink "$(basename "$1")")
    done
    REALPATH="$PWD/$(basename "$1")"
    cd "$OURPWD"
    echo "$REALPATH"
}

# =====
#
# Checks if a given application exists
#
# =====
function applicationExists()
{
    `which $1 >/dev/null`
}

# =====
#
# Helper function: show help
#
# =====
function showHelp
{
    cat "$BASH_SOURCE" | grep --color=never "# help:" | grep -v 'cat parameter' | sed 's/[ ]*# help:\([ ]\|\)//g' | sed "s~%scriptname%~$ENV_SCRIPTNAME~g"
}

# =====
#
# Helper function: show version
#
# =====
function showVersion
{
    echo "$ENV_SCRIPTNAME $ENV_VERSION - $ENV_AUTHOR <$ENV_EMAIL>"
}

# =====
#
# Task function: Print the last lines of log file
#
# =====
function printLog
{
    printHeader "Print the last $SETTING_LOG_LINES log lines"

    echo "Path: $FILE_LOG_ABSOLUTE" && echo

    printf %${WIDTH_VALUE}s | sed 's/ /─/g' && echo
    tail -n $SETTING_LOG_LINES "$FILE_LOG_ABSOLUTE"
    printf %${WIDTH_VALUE}s | sed 's/ /─/g' && echo
}

# =====
#
# Task function: Shows updated script with new version
#
# =====
function printUpdatedScript
{
    cat "$0" | sed "s/^# version: ENV_VERSION=.*/${ENV_VERSION_FORMAT}/g"
}

# =====
#
# Reads parameter
#
# =====
function readParameter
{
    # help:
    # help: Usage: %scriptname% [options...] sync
    # help:
    while [[ $# > 0 ]]; do
        case "$1" in
            # help:  -e,    --env-path                    Contains the environment path (default .env)
            # help:
            -e|--env-path)
                SETTING_ENV_PATH="$2"
                shift
                ;;
            -e=*|--env-path=*)
                SETTING_ENV_PATH="${1#*=}"
                ;;

            # help:  -dcs,  --disable-column-statistics   Disable mysql column statistics
            # help:
            -dcs|--disable-column-statistics)
                SETTING_DISABLE_COLUMN_STATISTICS=true
                ;;

            # help:
            # help:  -t,    --with-time                   Also outputs the time to each log entry (default: false).
            -t|--with-time)
                SETTING_SHOW_TIME=true
                ;;

            # help:  -v,    --verbose                     Set output to verbose (default: false).
            -v|--verbose)
                SETTING_VERBOSE=true
                ;;

            # help:  -c,    --color                       Colored output (default: false).
            -c|--color)
                SETTING_COLOR=true
                ;;

            # help:  -d,    --debug                       Set to debug mode. No longer performs any actions.
            # help:                                       Shows only the commands. (default: false).
            -d|--debug)
                SETTING_DEBUG=true
                ;;

            # help:  -l,    --print-log                   Print the log file
            -l|--print-log)
                printLog && echo && exit 0
                ;;

            # help:  -u,    --update-version              Shows this script with updated version read from VERSION
            -u|--update-version)
                printUpdatedScript && exit 0
                ;;

            # help:  -h,    --help                        Shows this help.
            -h|--help)
                echo && showVersion && showHelp && exit 0
                ;;

            # help:  -V,    --version                     Shows the version number.
            -V|--version)
                showVersion && exit 0
                ;;

	          # help:
            # collect all unknown parameters
            *)
                PARAMETERS+=("$1")
                ;;
        esac
        shift
    done
}

# =====
#
# Checks parameter
#
# =====
function checkParameter
{
    # get number of parameters
    numberParameters=${#PARAMETERS[@]}

    # check number of parameters
    if [ $numberParameters -le 0 ]; then
        echo && error "No task was given (\"dump\"). Abort."
        echo && showVersion && showHelp && exit 1
    fi

    local task="${PARAMETERS[0]}"

    # check task
    if [ "$task" != "dump" ]; then
        echo && error "Unknown task \"$task\". Abort."
        echo && showVersion && showHelp && exit 1
    fi
}

# =====
#
# Get task
#
# =====
function getTask
{
    local task="${PARAMETERS[0]}"

    echo "$task"
}

# =====
#
# Prepare .env path
#
# =====
function prepareName
{
    ENV_NAME=${ENV_NAME// /-}
}

# =====
#
# Prepare .env path
#
# =====
function prepareEnvPath
{
    [ "$SETTING_ENV_PATH" == "" ] && SETTING_ENV_PATH="$PATH_ROOT/$SETTING_DEFAULT_ENV_PATH"
    ([ ! -f "$SETTING_ENV_PATH" ] || [ "$SETTING_ENV_PATH" == "$SETTING_DEFAULT_ENV_PATH" ]) && SETTING_ENV_PATH="$PATH_ROOT/$SETTING_ENV_PATH"
}

# =====
#
# Check .env path
#
# =====
function checkEnvPath
{
    # check .env file
    if [ ! -f "$SETTING_ENV_PATH" ]; then
        error "The .env file '$SETTING_ENV_PATH' was not found." && exit 1
    fi
}

# =====
#
# Get data value.
#
# =====
function getDataValue()
{
    local defaultValue

    [ "$2" != "" ] && defaultValue="$2" || defaultValue="$TEXT_NO_FILTER_GIVEN"
    [ "$1" != "" ] && echo "$1" || echo "--- $defaultValue ---"
}

# =====
#
# Read configuration.
#
# =====
function readConfiguration()
{
    DB_USER=$(cat "$SETTING_ENV_PATH" | grep -v "^#" | grep --color=no "MYSQLDUMP_DATABASE_URL=" | sed 's/MYSQLDUMP_DATABASE_URL=mysql:\/\/\([^:]*\):\([^@]*\)@\([^:]*\):\([^\/]*\)\/\([^?]*\)\?\(.*\)/\1/')
    DB_PASS=$(cat "$SETTING_ENV_PATH" | grep -v "^#" | grep --color=no "MYSQLDUMP_DATABASE_URL=" | sed 's/MYSQLDUMP_DATABASE_URL=mysql:\/\/\([^:]*\):\([^@]*\)@\([^:]*\):\([^\/]*\)\/\([^?]*\)\?\(.*\)/\2/')
    DB_HOST=$(cat "$SETTING_ENV_PATH" | grep -v "^#" | grep --color=no "MYSQLDUMP_DATABASE_URL=" | sed 's/MYSQLDUMP_DATABASE_URL=mysql:\/\/\([^:]*\):\([^@]*\)@\([^:]*\):\([^\/]*\)\/\([^?]*\)\?\(.*\)/\3/')
    DB_PORT=$(cat "$SETTING_ENV_PATH" | grep -v "^#" | grep --color=no "MYSQLDUMP_DATABASE_URL=" | sed 's/MYSQLDUMP_DATABASE_URL=mysql:\/\/\([^:]*\):\([^@]*\)@\([^:]*\):\([^\/]*\)\/\([^?]*\)\?\(.*\)/\4/')
    DB_NAME=$(cat "$SETTING_ENV_PATH" | grep -v "^#" | grep --color=no "MYSQLDUMP_DATABASE_URL=" | sed 's/MYSQLDUMP_DATABASE_URL=mysql:\/\/\([^:]*\):\([^@]*\)@\([^:]*\):\([^\/]*\)\/\([^?]*\)\?\(.*\)/\5/')
    MYSQLDUMP_IGNORED_TABLES=$(cat "$SETTING_ENV_PATH" | grep -v "^#" | grep --color=no "MYSQLDUMP_IGNORED_TABLES=" | sed 's/[^=]\+=//' | tr -d '\r' | tr -d '\n' | xargs)
    MYSQLDUMP_FILTERED_TABLES=$(cat "$SETTING_ENV_PATH" | grep -v "^#" | grep --color=no "MYSQLDUMP_FILTERED_TABLES=" | sed 's/[^=]\+=//' | tr -d '\r' | tr -d '\n' | xargs)
    MYSQLDUMP_TABLES_NO_DATA=$(cat "$SETTING_ENV_PATH" | grep -v "^#" | grep --color=no "MYSQLDUMP_TABLES_NO_DATA=" | sed 's/[^=]\+=//' | tr -d '\r' | tr -d '\n' | xargs)
    MYSQLDUMP_TABLES_ONLY_DATA=$(cat "$SETTING_ENV_PATH" | grep -v "^#" | grep --color=no "MYSQLDUMP_TABLES_ONLY_DATA=" | sed 's/[^=]\+=//' | tr -d '\r' | tr -d '\n' | xargs)
}

# =====
#
# Check credentials.
#
# =====
function checkCredentials()
{
    if [ "$DB_USER" == "" ]; then
        error "Can't find db user within the .env file '$SETTING_ENV_PATH' (MYSQLDUMP_DATABASE_URL)." && exit 1
    fi
    if [ "$DB_PASS" == "" ]; then
        error "Can't find db password within the .env file '$SETTING_ENV_PATH' (MYSQLDUMP_DATABASE_URL)." && exit 1
    fi
    if [ "$DB_HOST" == "" ]; then
        error "Can't find db host within the .env file '$SETTING_ENV_PATH' (MYSQLDUMP_DATABASE_URL)." && exit 1
    fi
    if [ "$DB_NAME" == "" ]; then
        error "Can't find db name within the .env file '$SETTING_ENV_PATH' (MYSQLDUMP_DATABASE_URL)." && exit 1
    fi
}

# =====
#
# Create SQL directory.
#
# =====
function createSqlDirectory()
{
    # Build the sql path
    SQL_DIRECTORY="$PATH_ROOT/$SETTING_SQL_FIXTURE_PATH_RELATIVE"

    # Create sql path
    [ ! -d "$SQL_DIRECTORY" ] && info "Create directory \"$SQL_DIRECTORY\"" true true true && mkdir -p "$SQL_DIRECTORY"

    # Check sql path
    [ ! -d "$SQL_DIRECTORY" ] && error "Unable to create SQL directory \"$SQL_DIRECTORY\"" true true && exit 1
}

# =====
#
# Dump all tables.
#
# =====
function dumpTables()
{
    MYSQL_CONFIG="--no-tablespaces --default-character-set=utf8"
    if $SETTING_DISABLE_COLUMN_STATISTICS; then
        MYSQL_CONFIG+=" --column-statistics=0"
    fi

    # print info
    info "Start making snapshots of all tables within the following path: $SQL_DIRECTORY" true true true

    # read tables
    TABLES=$(MYSQL_PWD="$DB_PASS" mysql -NBA --host="$DB_HOST" --user="$DB_USER" --port="$DB_PORT" -D "$DB_NAME" -e 'show tables' --default-character-set=utf8)

    TABLES_COUNT=$(echo -e "$TABLES" | wc -l)

    # Print table count.
    info "Found $TABLES_COUNT tables." true true true

    # Print configuration information.
    value=$(getDataValue "$DB_USER")                                  && verbose "DB User:             $value"
    value=$(getDataValue "$DB_PASS")                                  && verbose "DB Password:         $value"
    value=$(getDataValue "$DB_HOST")                                  && verbose "DB Host:             $value"
    value=$(getDataValue "$DB_PORT")                                  && verbose "DB Port:             $value"
    value=$(getDataValue "$DB_NAME")                                  && verbose "DB Name:             $value"
    value=$(getDataValue "$MYSQLDUMP_IGNORED_TABLES")                 && verbose "Ignored tables:      $value"
    value=$(getDataValue "$MYSQLDUMP_FILTERED_TABLES")                && verbose "Filtered tables:     $value"
    value=$(getDataValue "$MYSQLDUMP_TABLES_NO_DATA")                 && verbose "Tables without data: $value"

    # make sql snapshot
    TABLES_DUMPED=0
    for TABLE in $TABLES; do

        # Build SQL path.
        SQL_FILE="${TABLE}.sql"
        SQL_PATH="$SQL_DIRECTORY/$SQL_FILE"
        SQL_FILTER=''

        # MYSQLDUMP_IGNORED_TABLES: Skip ignored tables.
        if [ "$MYSQLDUMP_IGNORED_TABLES" != "" ]; then
            IFS=','
            for TABLE_IGNORED in $MYSQLDUMP_IGNORED_TABLES; do
                if [[ "$TABLE" == $TABLE_IGNORED ]]; then
                    skipped "Table \"$TABLE\" ignored by config (rule: $TABLE_IGNORED)." true true true
                    continue 2
                fi
            done
        fi

        # MYSQLDUMP_TABLES_NO_DATA: No data.
        if [ "$SQL_FILTER" == "" ] && [ "$MYSQLDUMP_TABLES_NO_DATA" != "" ]; then
            IFS=','
            for TABLE_NO_DATA in $MYSQLDUMP_TABLES_NO_DATA; do
                if [[ "$TABLE" == $TABLE_NO_DATA ]]; then
                    SQL_FILTER='--no-data'
                    break
                fi
            done
        fi

        # MYSQLDUMP_TABLES_ONLY_DATA: No data.
        if [ "$SQL_FILTER" == "" ] && [ "$MYSQLDUMP_TABLES_ONLY_DATA" != "" ]; then
            IFS=','
            for TABLE_ONLY_DATA in $MYSQLDUMP_TABLES_ONLY_DATA; do
                if [[ "$TABLE" == $TABLE_ONLY_DATA ]]; then
                    SQL_FILTER='--no-create-info'
                    break
                fi
            done
        fi

        # MYSQLDUMP_FILTERED_TABLES: Build filter (custom).
        if [ "$SQL_FILTER" == "" ] && [ "$MYSQLDUMP_FILTERED_TABLES" != "" ]; then
            IFS=','
            for TABLE_FILTER in $MYSQLDUMP_FILTERED_TABLES; do
                TABLE_CURRENT=$(echo "$TABLE_FILTER" | sed 's/:.\+$//' | tr -d '"')

                if [ "$TABLE" == "$TABLE_CURRENT" ]; then
                    TABLE_FILTER_CURRENT=$(echo "$TABLE_FILTER" | sed 's/^[^:]\+://' | tr -d '"')
                    SQL_FILTER="--where=\"$TABLE_FILTER_CURRENT\""
                    break
                fi
            done
        fi

        # Build the MySQL command.
        COMMAND_MYSQL="mysqldump --host=\"$DB_HOST\" --user=\"$DB_USER\" --port=\"$DB_PORT\" \"$DB_NAME\" \"$TABLE\" $MYSQL_CONFIG $SQL_FILTER > \"$SQL_PATH\""

        # Print some information.
        info "Dump and write SQL file \"$SQL_PATH\"." true true true
        value=$(getDataValue "$SQL_FILTER" "$TEXT_NO_FILTER_GIVEN") && verbose "Filter: $value"

        # Only show the command
        if $SETTING_DEBUG; then
            info "Note: Debug mode is enabled. Shows only the command:"
            command "$COMMAND_MYSQL" && continue
        fi

        # Show the command
        $SETTING_VERBOSE && command "$COMMAND_MYSQL"

        # Add password and error redirect.
        COMMAND_MYSQL="(MYSQL_PWD=\"$DB_PASS\" $COMMAND_MYSQL) 2>&1"

        # Execute command.
        MESSAGE_ERROR=$(eval "$COMMAND_MYSQL")

        # get exit code from mysqldump
        EXIT_CODE=$?

        # exit code <> 0
        if [ $EXIT_CODE -ne 0 ]; then
            error "MySQL exit with exit code $EXIT_CODE -> abort ($MESSAGE_ERROR)"

            # delete failed file
            if [ -f "$SQL_PATH" ]; then
                info "Delete failed file: $SQL_PATH"

                rm "$SQL_PATH"
            fi

            exit $EXIT_CODE
        fi

        # check file: failed snapshot
        if [ ! -f "$SQL_PATH" ]; then
            error "Snapshot is not done: $SQL_PATH -> abort" && exit 1
        fi

        # check file: successful snapshot
        FILE_SIZE=$(du -h "$SQL_PATH" | cut -f1)
        success "Snapshot is done: $SQL_PATH (Size: $FILE_SIZE)" true true true

        # increase counter
        TABLES_DUMPED=$(( TABLES_DUMPED + 1 ))
    done
}

# =====
#
# Print success message.
#
# =====
function successMessage()
{
    success "$TABLES_DUMPED/$TABLES_COUNT tables successfully dumped."
}



# a) Read parameters.
readParameter "$@"

# b) Check parameter.
checkParameter && task=$(getTask)

# c) Register cleanup function
trap cleanup EXIT

# d) Lock application
setLock

# e) Prepare $NAME.
prepareName

# f) Prepare and check .env path.
prepareEnvPath && checkEnvPath

# g) read configuration && check db credentials.
readConfiguration && checkCredentials

# h) Create SQL directory.
createSqlDirectory

# i) Dump all tables.
dumpTables && successMessage
